template <typename T>
class Iterator;

template <typename Iterator>
class ReverseIterator;

template <typename T>
class Vector {
private:
    size_t cap;
    size_t size;
    T* m_ptr;

public:
    Vector() : m_ptr(nullptr), size(0), cap(0) {}

    ~Vector() {
        delete[] m_ptr;
    }
    
    Vector(const Vector& other) : size(other.size), cap(other.cap) {
        m_ptr = new T[cap];
        for (size_t i = 0; i < size; ++i) {
            m_ptr[i] = other.m_ptr[i];
        }
    }

    Vector& operator=(const Vector& other) {
        if (this != &other) {
            delete[] m_ptr;
            size = other.size;
            cap = other.cap;
            m_ptr = new T[cap];
            for (size_t i = 0; i < size; ++i) {
                m_ptr[i] = other.m_ptr[i];
            }
        }
        return *this;
    }
    
    Vector(Vector&& other) noexcept : size(other.size), cap(other.cap), m_ptr(other.m_ptr) {
        other.size = 0;
        other.cap = 0;
        other.m_ptr = nullptr;
    }
    
    Vector& operator=(Vector&& other) noexcept {
        if (this != &other) {
            delete[] m_ptr;
            size = other.size;
            cap = other.cap;
            m_ptr = other.m_ptr;
            other.size = 0;
            other.cap = 0;
            other.m_ptr = nullptr;
        }
        return *this;
    }
    
    size_t get_size() const {
        return size;
    }

    size_t get_cap() const {
        return cap;
    }

    T& operator[](size_t index) {
        if (index >= size) {
            throw std::out_of_range("Index out of range");
        }
        return m_ptr[index];
    }   

	const T& operator[](size_t index) const {
    	if (index >= size) {
        	throw std::out_of_range("Index out of range");
    	}
    	return m_ptr[index];
	}
  
    void push_back(const T& value) {
    	if (size == cap) {
        	size_t new_cap = (cap == 0) ? 1 : cap * 2;
        	T* new_ptr = new T[new_cap];
        	for (size_t i = 0; i < size; ++i) {
            	new_ptr[i] = m_ptr[i];
       	 	}
        	delete[] m_ptr;
        	m_ptr = new_ptr;
        	cap = new_cap;
    	}
    	m_ptr[size++] = value;
    }
    
    void pop_back() {
    	if (size > 0) {
        	--size;
    	} else {
			throw std::out_of_range("Index out of range");
		}
	}

    void clear() {
        size = 0;
    }
    
    template <typename... Args>
    T* emplace(size_t pos, Args&&... args) {
        if (pos > size) {
			throw std::out_of_range("Position out of range");
		}

        if (size == cap) {
            reserve(cap > 0 ? cap * 2 : 1);
        }

        for (size_t i = size; i > pos; --i) {
            m_ptr[i] = std::move(m_ptr[i - 1]);
        }

        new(&m_ptr[pos]) T(std::forward<Args>(args)...);
        ++size;
        return &m_ptr[pos];
    }
    
    template <typename... Args>
    void emplace_back(Args&&... args) {
        if (size == cap) {
            reserve(cap > 0 ? cap * 2 : 1);
        }

        new(&m_ptr[size++]) T(std::forward<Args>(args)...);
    }

    void resize(size_t new_size) {
        if (new_size > cap) {
            size_t new_cap = new_size;
            T* new_ptr = new T[new_cap];
            for (size_t i = 0; i < size; ++i) {
                new_ptr[i] = m_ptr[i];
            }
            delete[] m_ptr;
            m_ptr = new_ptr;
            cap = new_cap;
        }
        size = new_size;
    }

    void reserve(size_t new_cap) {
        if (new_cap > cap) {
            T* new_ptr = new T[new_cap];
            for (size_t i = 0; i < size; ++i) {
                new_ptr[i] = m_ptr[i];
            }
            delete[] m_ptr;
            m_ptr = new_ptr;
            cap = new_cap;
        }
    }
    
    void assign(size_t count, const T& value) {
        clear();
        reserve(count);
        for (size_t i = 0; i < count; ++i) {
            push_back(value);
        }
    }

    template <typename U>
    void assign(U first, U last) {
        clear();
        for (U it = first; it != last; ++it) {
            push_back(*it);
        }
    }
    
    void shrink_to_fit() {
        if (size < cap) {
            T* new_ptr = new T[size];
            for (size_t i = 0; i < size; ++i) {
                new_ptr[i] = m_ptr[i];
            }
            delete[] m_ptr;
            m_ptr = new_ptr;
            cap = size;
        }
    }

    T& at(size_t index) {
        if (index >= size) {
            throw std::out_of_range("Index out of range");
        }
        return m_ptr[index];
    }

    bool empty() const {
        return size == 0;
    }

	T& front() const {
        return m_ptr[0];
    }

	T& back() const {
        return m_ptr[size - 1];
    }
    
    T* data() const {
        return m_ptr;
    }
    
    void swap(Vector& other) {
        std::swap(size, other.size);
        std::swap(cap, other.cap);
        std::swap(m_ptr, other.m_ptr);
    }
    
    void insert(size_t pos, const T& value) {
    	if (pos > size) {
        	throw std::out_of_range("Position out of range");
    	}
    	if (size == cap) {
        	size_t new_cap = (cap == 0) ? 1 : cap * 2;
        	T* new_ptr = new T[new_cap];
        	for (size_t i = 0; i < pos; ++i) {
            	new_ptr[i] = m_ptr[i];
        	}
        	new_ptr[pos] = value;
        	for (size_t i = pos; i < size; ++i) {
            	new_ptr[i + 1] = m_ptr[i];
        	}
        	delete[] m_ptr;
        	m_ptr = new_ptr;
        	cap = new_cap;
    	} else {
        	for (size_t i = size; i > pos; --i) {
            	m_ptr[i] = m_ptr[i - 1];
        	}
        	m_ptr[pos] = value;
    	}
    	++size;
	}

	void erase(size_t pos) {
    	if (pos >= size) {
        	throw std::out_of_range("Position out of range");
    	}
    	for (size_t i = pos; i < size - 1; ++i) {
        	m_ptr[i] = m_ptr[i + 1];
    	}
    	--size;
	}
	
	template <typename Pred>
    void erase_if(Pred pred) {
        size_t new_size = 0;

        for (size_t i = 0; i < size; ++i) {
            if (!pred(m_ptr[i])) {
                m_ptr[new_size++] = std::move(m_ptr[i]);
            }
        }

        for (size_t i = new_size; i < size; ++i) {
            m_ptr[i].~T(); 
        }

        size = new_size;
    }

public:
    using iterator = Iterator<T>;
    using const_iterator = Iterator<const T>;
    using reverse_iterator = ReverseIterator<iterator>;
    using const_reverse_iterator = ReverseIterator<const_iterator>;

    iterator begin() {
        return iterator(m_ptr);
    }

    iterator end() {
        return iterator(m_ptr + size);
    }

    const_iterator cbegin() const {
        return const_iterator(m_ptr);
    }

    const_iterator cend() const {
        return const_iterator(m_ptr + size);
    }

    reverse_iterator rbegin() { 
		return reverse_iterator(end()); 
	}

    reverse_iterator rend() { 
		return reverse_iterator(begin()); 
	}

    const_reverse_iterator crbegin() const { 
		return const_reverse_iterator(cend()); 
	}

    const_reverse_iterator crend() const { 
		return const_reverse_iterator(cbegin()); 
	}
};

template <typename T>
class Iterator {
private:
    T* data;

public:
    using iterator_category = std::random_access_iterator_tag;
    using value_type = T;
    using difference_type = std::ptrdiff_t;
	using pointer = T*;
	using reference = T&;

    explicit Iterator(pointer ptr = nullptr) : data(ptr) {}

    reference operator*() const {
        return *data;
    }

    pointer operator->() const {
        return data;
    }

    Iterator& operator++() {
        ++data;
        return *this;
    }

    const Iterator operator++(int) {
        Iterator tmp = *this;
        ++data;
        return tmp;
    }

    Iterator& operator--() {
        --data;
        return *this;
    }

    const Iterator operator--(int) {
        Iterator tmp = *this;
        --data;
        return tmp;
    }

    Iterator operator+(difference_type n) const {
        return Iterator(data + n);
    }

    Iterator operator-(difference_type n) const {
        return Iterator(data - n);
    }

    difference_type operator-(const Iterator& other) const {
        return data - other.data;
    }

    bool operator==(const Iterator& other) const {
        return data == other.data;
    }

    bool operator!=(const Iterator& other) const {
        return data != other.data;
    }

    bool operator<(const Iterator& other) const {
        return data < other.data;
    }

    bool operator>(const Iterator& other) const {
        return data > other.data;
    }

    bool operator<=(const Iterator& other) const {
        return data <= other.data;
    }

    bool operator>=(const Iterator& other) const {
        return data >= other.data;
    }
};

template <typename Iterator>
class ReverseIterator {
public:
	using iterator_type = Iterator;
    using value_type = typename Iterator::value_type;
    using difference_type = typename Iterator::difference_type;
    using pointer = typename Iterator::pointer;
    using reference = typename Iterator::reference;

    explicit ReverseIterator(iterator_type it) : current(it) {}

    reference operator*() const {
        Iterator tmp = current;
        return *--tmp;
    }

    pointer operator->() const {
    	return &(**this);
    }

    ReverseIterator& operator++() {
        --current;
        return *this;
    }

    ReverseIterator operator++(int) {
        ReverseIterator tmp = *this;
        --current;
        return tmp;
    }

    ReverseIterator& operator--() {
        ++current;
        return *this;
    }

    ReverseIterator operator--(int) {
        ReverseIterator tmp = *this;
        ++current;
        return tmp;
    }

    ReverseIterator operator+(difference_type n) const {
        return ReverseIterator(current - n);
    }

    ReverseIterator operator-(difference_type n) const {
        return ReverseIterator(current + n);
    }

    difference_type operator-(const ReverseIterator& other) const {
        return other.current - current;
    }

    bool operator==(const ReverseIterator& other) const {
        return current == other.current;
    }

    bool operator!=(const ReverseIterator& other) const {
        return current != other.current;
    }

    bool operator<(const ReverseIterator& other) const {
        return current > other.current;
    }

    bool operator<=(const ReverseIterator& other) const {
        return current >= other.current;
    }

    bool operator>(const ReverseIterator& other) const {
        return current < other.current;
    }

    bool operator>=(const ReverseIterator& other) const {
        return current <= other.current;
    }

private:
    iterator_type current;
};
